#!/usr/bin/perl

use Mojo::Base -base;
use Mojo::Pg;

use Data::Dumper;
use Digest::MD5 qw(md5_hex);

use Config::Tiny;

exit main(@ARGV);

our ($cfg, $pg, $allprocsq, $procsrcq, $procmd5q);

sub main {
	my %actions = (
		'compare' => \&compprocs,
		'dump' => \&dumpprocs,
		'help' => \&help,
		'load' => \&loadproc,
		'save' => \&saveproc,
	);
	
	my %commands = (
		'compprocs' => \&compprocs,
		'dumpprocs' => \&dumpprocs,
		'loadproc' => \&loadproc,
		'saveproc' => \&saveproc,
	);
	
	($0) = ($0 =~ m|/?(\w+)$|);

	my $handler = $commands{$0};

	$handler = $actions{shift @_ // 'help'} unless $handler;

 	die "$0: don't know what to do" unless $handler;

	$cfg = Config::Tiny->read('../etc/jobcenter.conf');
	die 'Config Errror: ' . Config::Tiny->errstr() unless $cfg;
	#print Dumper($cfg);

	$ENV{'PGAPPNAME'} = $0;
	$pg = Mojo::Pg->new(
		'postgresql://'
		. $cfg->{admin}->{user}
		. ':' . $cfg->{admin}->{pass}
		. '@' . $cfg->{pg}->{host}
		. ':' . $cfg->{pg}->{port}
		. '/' . $cfg->{pg}->{db}
	);

	return &$handler(@_);
}

sub help {
	say "use the source!";
}

sub dumpprocs {
	my $funcs = $pg->db->dollar_only->query($allprocsq, $cfg->{pg}->{db});
	
	while (my $f = $funcs->hash) {
		say "dumping $f->{name}";
		open my $o, '>', "procs/$f->{name}.sql" or die "urgh";
		print $o $f->{code};
		close $o; 
	}

	return 0;
}

sub compprocs {
	opendir my $dh, 'procs' or die "ugh";
	my @filefuncs = grep { /.sql$/ && -f "procs/$_" } readdir($dh);
	closedir $dh;

	my $diffs = 0;
				
	foreach my $fn (@filefuncs) {
		my ($f) = $fn =~ /^(.*)\.sql$/;
		my $dbfunc = $pg->db->dollar_only->query($procsrcq, $cfg->{pg}->{db}, $f)->array;
		die "no func $f in the db?" unless $dbfunc and @$dbfunc and $$dbfunc[0];
		my $procmd5 = $pg->db->dollar_only->query($procmd5q, $f)->array;
		die "no func $f in the procs table?" unless $procmd5 and @$procmd5 and $$procmd5[0];
		$procmd5 = $$procmd5[0];
		my $filemd5 = md5sum($fn);
		my $dbmd5 = md5_hex($$dbfunc[0]);
		if ($procmd5 ne $dbmd5 and $filemd5 ne $procmd5) {
			say "$f differs between db and procs table and file";
			$diffs += 2;
		} elsif ($filemd5 ne $procmd5) {
			say "$f differs between procs table and file";
			$diffs++;
		} elsif ($filemd5 ne $dbmd5) {
			say "$f differs between db and file";
			$diffs++;
		} else {
			#say " (did $f)";
		}
	}

	if ($diffs) {
		say "found $diffs differences";
	} else {
		#say "no differences found";
	}

	return 0;
}

sub loadproc {
	my $proc = shift;
	die "usage: loadproc <procname>" unless $proc;
	die "$proc not found in procs dir" unless -f "procs/$proc.sql";

	my $dbmd5 = $pg->db->dollar_only->query($procsrcq, $cfg->{pg}->{db}, $proc)->array;
	unless ($dbmd5 and @$dbmd5 and $$dbmd5[0]) {
		warn "no proc $proc in the db?";
		$dbmd5 = undef;
	} else {
		$dbmd5 = md5_hex($$dbmd5[0]);
	}
	my $procmd5 = $pg->db->dollar_only->query($procmd5q, $proc)->array;
	unless ($procmd5 and @$procmd5 and $$procmd5[0]) {
		warn "no func $proc in the procs table?";
		$procmd5 = undef;
	} else {
		$procmd5 = $$procmd5[0];
	}

	die "proc $proc exists in db and not in proc table, refusing to load" if $dbmd5 and not $procmd5;
	die "proc $proc was changed in the db, refusing to load" if $dbmd5 and $procmd5 and $procmd5 ne $dbmd5;

	open my $procfd, '<', "procs/$proc.sql" or die "Cannot open $proc: $!";
	my $procsrc = do { local $/; <$procfd>; };
	close $procfd;

        my $filemd5 = md5_hex($procsrc);

        if ($procmd5 and $filemd5 eq $procmd5) {
        	say "$proc is alread up-to-date";
        	return 0;
	}

	$pg->db->dollar_only->query($procsrc);
	
	if ($dbmd5) {
		$pg->db->dollar_only->query(q|update _procs set md5=$1 where "name"=$2|, $filemd5, $proc);
	} else {
		$pg->db->dollar_only->query(q|insert into _procs ("name", md5) values ($1, $2)|, $proc, $filemd5);
	}
}

sub saveproc {
	my $proc = shift;
	die "usage: saveproc <procname>" unless $proc;
	warn "$proc not found in procs dir" unless -f "procs/$proc.sql";

	my $dbprocsrc = $pg->db->dollar_only->query($procsrcq, $cfg->{pg}->{db}, $proc)->array;
	die "no proc $proc in the db?" unless $dbprocsrc and @$dbprocsrc and $$dbprocsrc[0];
	$dbprocsrc = $$dbprocsrc[0];

	my $dbmd5 = md5_hex($dbprocsrc);

	open my $procfd, '>', "procs/$proc.sql" or die "Cannot open $proc for writing: $!";
	print $procfd $dbprocsrc;
	close $procfd;

	$pg->db->dollar_only->query(q|update _procs set md5=$1 where "name"=$2|, $dbmd5, $proc);
}
	

sub md5sum {
	my $f = shift;
	open my $fh, '<', "procs/$f" or die "oegh";
	binmode $fh;
	my $md5sum = Digest::MD5->new->addfile($fh)->hexdigest;
	close $fh;
	return $md5sum;
}

BEGIN {
$allprocsq = <<'EOT';
SELECT
  p.proname as "name",
  pg_catalog.pg_get_functiondef(p.oid) as "code"
FROM pg_catalog.pg_proc p
  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE pg_catalog.pg_function_is_visible(p.oid)
  AND n.nspname = $1
  ORDER BY 1;
EOT

$procsrcq = <<'EOT';
SELECT
  pg_catalog.pg_get_functiondef(p.oid) as "code"
FROM pg_catalog.pg_proc p
  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE pg_catalog.pg_function_is_visible(p.oid)
  AND n.nspname = $1
  AND p.proname = $2
EOT

$procmd5q = <<'EOT';
SELECT md5 FROM _procs WHERE "name" = $1
EOT
}
