#!/usr/bin/perl

use Mojo::Base -base;

#
# Mojo's default reactor uses EV, and EV does not play nice with signals
# without some handholding. We either can try to detect EV and do the
# handholding, or try to prevent Mojo using EV.
#
BEGIN {
	$ENV{'MOJO_REACTOR'} = 'Mojo::Reactor::Poll';
}

# standard perl
use Data::Dumper;
use FindBin;
use Getopt::Long;
use Time::HiRes qw( time );

# from cpan
use Config::Tiny;

# more mojo
use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Pg;
use Mojo::Server;

# JobCenter
use lib "$FindBin::Bin/../lib";
use JobCenter::Util qw(:daemon);

# transaction backoff time
our $backoff = 0.1;

# some package globals
our ($log, $pg, $tmr, $next);

exit main();

sub calljobtaskproc {
	my ($db, $proc, $arg, $retries) = @_;
	$retries //= 1;
	local $@;
	eval {
		#$log->debug("select * from $proc($arg)");
		$db->query("select * from $proc(\$1)", $arg, sub {
			my ($db, $err, $res) = @_;
			#$log->debug("calljobtaskproc callback");
			my $sqlstate = $res->sth->state;
			if ($sqlstate eq '40001' or $sqlstate eq '40P01') {
				$log->debug("scheduling retry of calljobtaskproc $proc$arg: $sqlstate");
				$res->sth->finish;
				# try a backoff with a bit of randomness
				Mojo::IOLoop->timer(($backoff + rand($retries * $backoff)) => sub {
					$log->debug("retry $retries of calljobtaskproc $proc$arg");
					calljobtaskproc($db, $proc, $arg, $retries + 1);
				});
				return;
			}
			if ($err) {
				$res->sth->finish;
				$log->error("calljobtaskproc $proc$arg: got errror $err");
				return;
			}
			my $r = $res->array; # fixme: can wel call this in a error case?
			$res->sth->finish;
			#print 'r: ', Dumper($r);
			return unless ref $r eq 'ARRAY' and defined @$r[1];
			my ($error, $jobtask) = @$r;
			if ($error) {
				$log->debug("calljobtaskproc: error condition, calling errortask $jobtask");
				calljobtaskproc($db, 'do_jobtaskerror', $jobtask);
			} else {
				$log->debug("do_next_cb: next: $jobtask");
				calljobtaskproc($db, 'do_jobtask', $jobtask);
			}
			return;
		});
	};
	$log->debug('calljobtaskproc threw error: ' . $@) if $@;
}

sub do_timeout {
	my ($loop) = @_;
	local $@;
	eval {
		$tmr = undef;
		$pg->db->query(q[select do_timeout()], sub {
			my ($db, $err, $res) = @_;
			my $sqlstate = $res->sth->state;
			if ($sqlstate eq '40001' or $sqlstate eq '40P01') {
				$log->debug("scheduling retry of do_timeout");
				Mojo::IOLoop->timer($backoff => \&do_timeout);
			}
			if ($err) {
				$res->sth->finish;
				$log->error("do_timeout got errror $err");
				return;
			}
			my $r = $res->array;
			$res->sth->finish;
			if ($r and ref $r eq 'ARRAY' and defined @$r[0]) {
				my $foo = my $bar = @$r[0] + 0;
				$foo = .1 if $foo < .1; # fixme: minimum resolution?
				my $now = time();
				$next = $now + $foo;
				$log->debug("do_timeout: timer now $foo ($bar)");
				Mojo::IOLoop->remove($tmr) if $tmr;
				$tmr = Mojo::IOLoop->timer($foo => \&do_timeout);
			}
		});
	};
	if ($@) {
		$log->error("do_timeout threw error: $@");
		$next = time()*2;
	}
	#say "do_timeout done\n";
}

sub do_settimer {
	my ($pubsub, $payload) = @_;
	my $now = time();

	# payload is an empty string when no payload was sent..
	#$log->debug("settimer: " . ($payload || '<null>') . " now: $now next: $next");

	if ($payload) {
		if ($now + $payload < $next or $next <= $now) {
			$payload = .1 if $payload < .1;
			$log->debug("settimer: $payload");

			Mojo::IOLoop->remove($tmr) if $tmr;
			$tmr = Mojo::IOLoop->timer($payload => \&do_timeout);
			$next = $now + $payload;
		}
	} elsif ($tmr) {
		$log->debug("disabling timer");
		Mojo::IOLoop->remove($tmr);
		undef $tmr;
		$next = $now;
	}
}

sub do_slash {
	my $c = shift;
	# fixme: do something usefull here?
	$c->render(text => "Hello World!");
}

sub main {
	my $config = "$FindBin::Bin/../etc/jobcenter.conf";
	my $daemon = 1;

	GetOptions(
		'config=s' => \$config,
		'daemon!' => \$daemon,
	) or die "Error in command line arguments\n";

	$ENV{'PGAPPNAME'} = "maestro [$$]";
	my $cfg = Config::Tiny->read($config);
	die 'Config Errror: ' . Config::Tiny->errstr() unless $cfg;
	#print Dumper($cfg);

	my $pid_file = $cfg->{pid_file} // "$FindBin::Bin/../log/maestro.pid";
	die "maestro already running?" if check_pid($pid_file);

	$log = app->log;
	$log->path("$FindBin::Bin/../log/maestro.log") if $daemon;

	Mojo::Server::daemonize() if $daemon;

	ensure_pid_file($pid_file, $log);

	$pg = Mojo::Pg->new(
		'postgresql://'
		. $cfg->{maestro}->{user}
		. ':' . $cfg->{maestro}->{pass}
		. '@' . ( $cfg->{pg}->{host} // '' )
		. ( ($cfg->{pg}->{port}) ? ':' . $cfg->{pg}->{port} : '' )
		. '/' . $cfg->{pg}->{db}
	);
	$pg->max_connections(5);

	$pg->on(connection => sub { my ($e, $dbh) = @_;  $log->debug("pg: new connection: $dbh"); });

	for my $listen (qw[jobtask jobtaskdone jobtaskerror ping]) {
		$pg->pubsub->listen($listen => sub {
			my ($pubsub, $payload) = @_;
			$log->debug("got NOTIFY \"$listen\", '$payload';");
			calljobtaskproc($pg->db, "do_$listen", $payload);
		});
	}

	$next = time()*2; # something far far away..
	$pg->pubsub->listen('timer' => \&do_settimer);

	my $mopupper = Mojo::IOLoop->recurring(60 => sub {
		$log->debug('do_archival_and_cleanup');
		calljobtaskproc($pg->db, 'do_archival_and_cleanup', '(dummy)');
	});

	local $SIG{TERM} = local $SIG{INT} = sub { Mojo::IOLoop->stop };

	get('/' => \&do_slash);

	app->start('daemon', '-l', 'http://*:' . ( $cfg->{maestro}->{listenport} // '6502' ) );

	$log->info('the end is nigh!');
	unlink $pid_file if -w $pid_file;

	return 0;
}

1;

