#!/usr/bin/env perl

use FindBin;
#use lib "$FindBin::Bin/../lib";
use Mojo::Base -base;
use Mojo::IOLoop;
use Mojo::Pg;

exit maestro::main();

package maestro;

use Config::Tiny;
use Data::Dumper;
use Time::HiRes qw( time ); #qw( clock_gettime CLOCK_REALTIME );

# some globals
our ($pg, $tmr, $next);

sub do_check_workers {
	say "checking workers";
	$pg->db->query(q|select do_check_workers()|, sub { return; });
}

sub do_next_cb {
	my ($db, $err, $res) = @_;
	if ($err) {
		say "got errror $err";
		return;
	}
	my $r = $res->array;
	$res->sth->finish;
	#print 'r: ', Dumper($r);
	return unless @$r and defined @$r[1];
	my ($error, $jobtask) = @$r;
	if ($error) {
		say "do_next_cb: error condition, calling errortask ($jobtask)";
		do_jobtaskerror($db, $jobtask);
	} else {
		say "do_next_cb: next: ($jobtask)";
		do_jobtask($db, $jobtask);
	}
}

sub do_jobtask {
	my ($db, $jobtask) = @_;
	eval {
		$db->query(q[select * from do_jobtask($1)], $jobtask, \&do_next_cb);
	};
	say $@ if $@;
	#say "done with do_jobtask\n";
}

sub do_jobtaskerror {
	my ($db, $jobtask) = @_;
	eval {
		$db->query(q[select * from do_jobtaskerror($1)], $jobtask, \&do_next_cb);
	};
	say $@ if $@;
	#say "done with do_jobtaskerror\n";
}

sub do_notify_jobtaskdone {
	my ($pubsub, $payload) = @_;
	say "got NOTIFY jobtaskdone, '$payload';";
	eval {
		$pg->db->query(q[select * from do_jobtaskdone($1)], $payload, \&do_next_cb );
	};
	say $@ if $@;
	#say "done with jobtaskdone\n";
}

sub do_notify_jobtaskerror {
	my ($pubsub, $payload) = @_;
	say "got NOTIFY jobtaskerror, '$payload';";
	eval {
		$pg->db->query(q[select * from do_jobtaskerror($1)], $payload, \&do_next_cb );
	};
	say $@ if $@;
	#say "done with jobtaskerror\n";
}

sub do_ping {
	my ($pubsub, $payload) = @_;
	say "ping from $payload";
	$pg->db->query(q[select do_ping($1)], $payload, sub {} );
	say "done with do_ping\n";
}

sub do_timeout {
	my ($loop) = @_;
	say "do_timeout called!";
	eval {
		my $res = $pg->db->query(q[select do_timeout()])->array;
		if ($res and @$res and @$res[0]) {
			my $foo = @$res[0];
			$foo = 1 if $foo < 1;
			my $now = time();
			$next = $now + $foo;
			say "now setting timer to $foo, now: $now, next: $next";
			#Mojo::IOLoop->remove($tmr) if $tmr;
			$tmr = Mojo::IOLoop->timer($foo => \&do_timeout);
		}
	};
	if ($@) {
		say $@;
		$next = time()*2;
	}
	say "do_timeout done\n";
}

sub do_settimer {
	my ($pubsub, $payload) = @_;
	#my $ts = clock_gettime(CLOCK_REALTIME);
	my $now = time();

	say "timer: $payload now: $now next: $next";

	if ($payload) {
		if ($now + $payload < $next or $next <= $now) {
			$payload = 1 if $payload < 1;
			say "setting timer to $payload";

			Mojo::IOLoop->remove($tmr) if $tmr;
			$tmr = Mojo::IOLoop->timer($payload => \&do_timeout);
			$next = $now + $payload;
		}
	} else {
		say "disabling timer";
		Mojo::IOLoop->remove($tmr) if $tmr;
		undef $tmr;
		$next = $now;
	}
}

sub main {
	$ENV{'PGAPPNAME'} = "maestro [$$]";
	my $cfg = Config::Tiny->read("$FindBin::Bin/../etc/jobcenter.conf");
	die 'Config Errror: ' . Config::Tiny->errstr() unless $cfg;
	#print Dumper($cfg);

	$pg = Mojo::Pg->new(
		'postgresql://'
		. $cfg->{maestro}->{user}
		. ':' . $cfg->{maestro}->{pass}
		. '@' . $cfg->{pg}->{host}
		. ':' . $cfg->{pg}->{port}
		. '/' . $cfg->{pg}->{db}
	);

	$pg->on(connection => sub { my ($e, $dbh) = @_;  say "pg: new connection: $dbh"; });

	$pg->pubsub->listen( 'jobtaskdone' => \&do_notify_jobtaskdone );

	$pg->pubsub->listen( 'jobtaskerror' => \&do_notify_jobtaskerror );

	$next = time()*2; # something large
	$pg->pubsub->listen( 'timer' => \&do_settimer );

	$pg->pubsub->listen( 'ping' => \&do_ping );

	my $check_workers = Mojo::IOLoop->recurring( 60 => \&do_check_workers );

	#local $SIG{TERM} = local $SIG{INT} = sub { Mojo::IOLoop->stop };
	local $SIG{TERM} = sub { Mojo::IOLoop->stop };
	
	Mojo::IOLoop->start;

	say "the end is nigh!"
}

1;

